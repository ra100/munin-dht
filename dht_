#!/usr/bin/python
# vim: set fileencoding=utf-8 :
#
# Copyright 2015 Rastislav Å varba <git@ra100.net>
#
# Licesnse: GPLv3
#
# A munin plugin to measure temperature and humidity
#
# USAGE
# Please make the symlink as dht_TYPE_GPIOPIN
# Example dht_11_4
#
# add lines to munin plugins conf, usualy /etc/munin/plugin-conf.d/munin-node
#   [dht_*]
#   user root
#
#   [dht_11_4]
#   env.where Living room
#   env.try_count 10
#   env.average 4
#   env.debug false
#   env.sleep 1   
#
#%# capabilities=autoconf
#%# family=contrib

import os
import sys
import math
import time
import dhtreader

sensor_type = sys.argv[0].split('_', 2)[1]
sensor_gpio = sys.argv[0].split('_', 2)[2]
where = os.getenv('where', 'N/A')
try_count = int(os.getenv('try_count', 15))
average = int(os.getenv('average', 4))
debug = os.getenv('debug', 'false')
sleep = float(os.getenv('sleep', 1))

def print_config():
    print """graph_title Humidity and Temperature in %(where)s
graph_category environment
graph_info Show temperature, humidity and dewpoint in %(where)s with sensor %(sensor_type)s on GPIO %(sensor_gpio)s
temp.label Temperature
temp.type GAUGE
temp.max 100
temp.min -50
hum.label Humidity
hum.type GAUGE
hum.max 100
hum.min 0
hum.critical 70
hum.warning 60
dp.label Dewpoint
dp.type GAUGE
"""  % dict(sensor_type=sensor_type, where=where, sensor_gpio=sensor_gpio)
    if debug == "true":
        print """readings.label Successful readings
readings.type GAUGE
tries.label All readings
tries.type GAUGE
"""

K2 = 17.5043
K3 = 241.2

def calc_dewpoint(temp, hum):
    """
    See https://de.wikipedia.org/wiki/Taupunkt

    >>> calc_dewpoint(20, 100)
    20.0
    """
    phi = hum / 100.0
    theta = temp

    lnphi = math.log(phi)
    z = ((K2 * theta) /  (K3 + theta)) + lnphi
    n = ((K2 * K3) / (K3 + theta)) - lnphi

    return K3 * (z/n)
   

def remove_outlier(readings):
    if (len(readings) == 1):
        return readings[0]
    #count average temp, hum, temp abberation, hum abberation
    avg = [0, 0, 0, 0]
    for val in readings:
        avg[0] += val[0]
        avg[1] += val[1]
    avg[0] = avg[0]/len(readings)
    avg[1] = avg[1]/len(readings)
    if (len(readings) == 2):
        return avg
    #average abberation
    abberations = []
    for val in readings:
        abb = [abs(avg[0] - val[0]), abs(avg[1] - val[1])]
        abberations.append(abb)
        avg[2] += abb[0]
        avg[3] += abb[1]
    avg[2] = (avg[2]/len(readings))
    avg[3] = (avg[3]/len(readings))
    vals = 0
    avg[0] = 0
    avg[1] = 0
    for index,val in enumerate(readings):
        if (abberations[index][0] <= avg[2]) and (abberations[index][1] <= avg[3]):
            vals += 1
            avg[0] += val[0]
            avg[1] += val[1]
    avg[0] = avg[0]/vals
    avg[1] = avg[1]/vals
    return avg


def write_to_file(filename, val1, val2):
    with open(filename, "w") as text_file:
        text_file.write(str(val1))
        text_file.write("\n")
        text_file.write(str(val2))


def check_old_values(temp):
    filename = "/tmp/dht_{0}_{1}".format(sensor_type, sensor_gpio)
    if os.path.isfile(filename): 
        with open(filename, "r") as text_file:
            data = text_file.read().splitlines(True)
        if len(data) > 0:
            data[0] = data[0].strip("\n")
            if len(data) == 1:
                write_to_file(filename, data[0], temp)
            if len(data) == 2:
                diverge = 0
                if abs(float(data[0]) - temp) > 20:
                    diverge += 1
                if abs(float(data[1]) - temp) > 20:
                    diverge += 1
                if diverge == 0:
                    write_to_file(filename, data[1], temp)
                    return True
                if diverge == 1:
                    if abs(float(data[0]) - temp) > 20: #assume that 2 bad readings in row won't ever happen second old must be wrong
                        write_to_file(filename, data[0], temp)
                    else:
                        write_to_file(filename, data[1], temp)
                if diverge == 2: #assume that 2 bad readings in row won't ever happen
                    return False
                              
    else:
        with open(filename, "w") as text_file:
            text_file.write(str(temp))
        return True



def fetch_values(sensor_type, sensor_gpio):
    reader = dhtreader.init()
    values = None
    tries = 0
    good = 0
    readings = []
    while (good < average and tries < try_count):
        values = dhtreader.read(sensor_type, sensor_gpio)
        if values != None:
            readings.append(values)
            good += 1
        tries += 1
        time.sleep(sleep)
    
    results = remove_outlier(readings)
    
    temp = results[0]
    hum = results[1]
    dp = calc_dewpoint(temp, hum)
    if check_old_values(temp):
        print "temp.value %f" % temp
        print "hum.value %f" % hum
        print "dp.value %f" % dp
        if debug == "true":
            print "readings.value %f" % good
            print "tries.value %f" % tries


def main(args):
    if len(args) > 1:
        if args[1] in [ 'autoconf', 'detect' ]:
            try:
                fetch_raw()
                print "yes"
                return 0
            except:
                print "no"
                return 1
        elif args[1] == 'config':
            try:
                print_config()
            except Exception as e:
                print >>sys.stderr, "Failed to fetch config: '%s'" % e
                return 1
            return 0
    try:
        sensor_type = sys.argv[0].split('_', 2)[1]
        sensor_gpio = sys.argv[0].split('_', 2)[2]
        fetch_values(int(sensor_type) , int(sensor_gpio))
    except Exception as e:
        print >>sys.stderr, "Failed to fetch values: '%s'" % e
        return 1
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))
